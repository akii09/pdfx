{
  "$schema": "https://pdfx.akashpise.dev/schema/registry-item.json",
  "name": "table",
  "type": "registry:ui",
  "title": "Table",
  "description": "Composable table with Table, TableRow, TableCell",
  "files": [
    {
      "path": "components/pdfx/pdfx-table.tsx",
      "content": "import { Text as PDFText, StyleSheet, View } from '@react-pdf/renderer';\nimport type { Style } from '@react-pdf/types';\nimport React from 'react';\nimport { theme as defaultTheme } from '../lib/pdfx-theme';\n\n/**\n * Table visual variant.\n * - `line`: Horizontal dividers only (Stripe-style). Best for invoices, receipts, quotes.\n * - `grid`: Full borders on all sides. Best for reports, data sheets, comparison tables.\n * - `minimal`: No borders. Structure via spacing/typography. Best for certificates, elegant reports.\n * - `striped`: Alternating row backgrounds with subtle borders. Modern, easy to scan.\n */\nexport type TableVariant = 'line' | 'grid' | 'minimal' | 'striped';\n\n/**\n * Props for the Table component.\n *\n * @example\n * ```tsx\n * <Table variant=\"line\">\n *   <TableHeader>\n *     <TableRow header>...</TableRow>\n *   </TableHeader>\n *   <TableBody>\n *     <TableRow>...</TableRow>\n *   </TableBody>\n * </Table>\n * ```\n */\nexport interface TableProps {\n  /** Custom styles to merge with component defaults */\n  style?: Style;\n  /** Content to render */\n  children: React.ReactNode;\n  /** Visual variant. line = horizontal dividers. grid = full borders. minimal = borderless. striped = alternating rows. */\n  variant?: TableVariant;\n  /** Enable automatic zebra striping on body rows (auto-enabled for 'striped' variant). */\n  zebraStripe?: boolean;\n}\n\n/** Props for semantic table section wrappers. */\nexport interface TableSectionProps {\n  /** Custom styles to merge with component defaults */\n  style?: Style;\n  /** Content to render */\n  children: React.ReactNode;\n}\n\n/** Props for the TableRow component. */\nexport interface TableRowProps {\n  /** Custom styles to merge with component defaults */\n  style?: Style;\n  /** Content to render */\n  children: React.ReactNode;\n  /** Header row — uses distinct background, semibold text, and semantic separator. */\n  header?: boolean;\n  /** Footer row — top border, bold text for totals/summaries. */\n  footer?: boolean;\n  /** Alternating stripe background (applied automatically when using zebraStripe). */\n  stripe?: boolean;\n  /** Override table variant (default from parent Table). */\n  variant?: TableVariant;\n}\n\n/** Props for the TableCell component. */\nexport interface TableCellProps {\n  /** Custom styles to merge with component defaults */\n  style?: Style;\n  /** Content to render */\n  children: React.ReactNode;\n  /** Header cell styling. */\n  header?: boolean;\n  /** Footer cell styling (bold). */\n  footer?: boolean;\n  /** Text alignment. Use 'right' for amounts/numbers. */\n  align?: 'left' | 'center' | 'right';\n  /** Column width. String ('50%') or number (pts). Omit for equal-width flex. */\n  width?: string | number;\n  /** Override table variant (default from parent TableRow). */\n  variant?: TableVariant;\n  /** Internal: omit right border (last cell in row). */\n  _last?: boolean;\n}\n\n// ─── Theme Caching ────────────────────────────────────────────────────────────\nlet cachedTheme: PdfxTheme | null = null;\nlet cachedStyles: ReturnType<typeof createTableStyles> | null = null;\n\nfunction getStyles(t: any) {\n  if (cachedTheme !== t || !cachedStyles) {\n    cachedStyles = createTableStyles(t);\n    cachedTheme = t;\n  }\n  return cachedStyles;\n}\n\n/** Creates table styles from theme tokens. Zero hardcoded values. */\nfunction createTableStyles(t: any) {\n  const { spacing, borderRadius, letterSpacing, fontWeights, typography } = t.primitives;\n  const borderWidth = spacing[0.5];\n  const borderColor = t.colors.border;\n\n  return StyleSheet.create({\n    // ─── Container ─────────────────────────────────────────────────────────\n    table: {\n      display: 'flex',\n      flexDirection: 'column',\n      width: '100%',\n      marginBottom: t.spacing.componentGap,\n    },\n    tableGrid: {\n      borderWidth: borderWidth,\n      borderColor: borderColor,\n      borderStyle: 'solid',\n      borderTopLeftRadius: borderRadius.md,\n      borderTopRightRadius: borderRadius.md,\n      borderBottomLeftRadius: borderRadius.md,\n      borderBottomRightRadius: borderRadius.md,\n      overflow: 'hidden',\n    },\n    tableLine: {\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    tableMinimal: {\n      paddingVertical: spacing[2],\n    },\n    tableStriped: {\n      borderTopWidth: borderWidth,\n      borderTopColor: borderColor,\n      borderTopStyle: 'solid',\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n\n    // ─── Rows ─────────────────────────────────────────────────────────────\n    row: {\n      flexDirection: 'row',\n      display: 'flex',\n    },\n    rowGrid: {\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowLine: {\n      borderBottomWidth: 0,\n    },\n    rowMinimal: {\n      paddingVertical: spacing[1],\n    },\n    rowStriped: {},\n    rowHeaderGrid: {\n      backgroundColor: t.colors.muted,\n      borderBottomWidth: borderWidth * 2,\n      borderBottomColor: t.colors.foreground,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderLine: {\n      borderBottomWidth: borderWidth * 2,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderMinimal: {\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderStriped: {\n      backgroundColor: t.colors.muted,\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowFooter: {\n      borderTopWidth: borderWidth * 2,\n      borderTopColor: borderColor,\n      borderTopStyle: 'solid',\n    },\n    rowFooterStriped: {\n      borderTopWidth: borderWidth,\n      borderTopColor: borderColor,\n      borderTopStyle: 'solid',\n      backgroundColor: t.colors.muted,\n    },\n    rowStripe: {\n      backgroundColor: t.colors.muted,\n    },\n\n    // ─── Cells ─────────────────────────────────────────────────────────────\n    cell: {\n      flex: 1,\n      paddingVertical: spacing[3],\n      paddingHorizontal: spacing[4],\n    },\n    cellFixed: {\n      flex: 0,\n    },\n    cellGridBorder: {\n      borderRightWidth: borderWidth,\n      borderRightColor: borderColor,\n      borderRightStyle: 'solid',\n    },\n    cellMinimal: {\n      paddingVertical: spacing[2],\n      paddingHorizontal: spacing[3],\n    },\n    cellStriped: {\n      paddingVertical: spacing[2.5] ?? spacing[3],\n      paddingHorizontal: spacing[4],\n    },\n\n    // ─── Cell Text Styles ──────────────────────────────────────────────────\n    cellText: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n    },\n    cellTextHeaderGrid: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.semibold,\n    },\n    cellTextHeaderLine: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: typography.xs,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.mutedForeground,\n      fontWeight: fontWeights.semibold,\n      textTransform: 'uppercase',\n      letterSpacing: letterSpacing.wider * 10,\n    },\n    cellTextHeaderMinimal: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: typography.sm,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.mutedForeground,\n      fontWeight: fontWeights.medium,\n    },\n    cellTextHeaderStriped: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: typography.sm,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.semibold,\n    },\n    cellTextFooter: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.semibold,\n    },\n  });\n}\n\n// ─── Helper: Process children and propagate variant ───────────────────────────\nfunction processTableChildren(\n  children: React.ReactNode,\n  variant: TableVariant,\n  zebraStripe: boolean\n): React.ReactNode {\n  let bodyRowIndex = 0;\n\n  return React.Children.map(children, (child) => {\n    if (!React.isValidElement(child)) return child;\n\n    if (child.type === TableHeader || child.type === TableBody || child.type === TableFooter) {\n      const isBody = child.type === TableBody;\n      const sectionChild = child as React.ReactElement<TableSectionProps>;\n      const sectionChildren = React.Children.map(sectionChild.props.children, (rowChild) => {\n        if (React.isValidElement(rowChild) && rowChild.type === TableRow) {\n          const rowProps: Partial<TableRowProps> = { variant };\n\n          if (isBody && zebraStripe) {\n            const isStripe = bodyRowIndex % 2 === 1;\n            bodyRowIndex++;\n            if (isStripe) {\n              rowProps.stripe = true;\n            }\n          }\n\n          return React.cloneElement(rowChild as React.ReactElement<TableRowProps>, rowProps);\n        }\n        return rowChild;\n      });\n\n      return React.cloneElement(child, {}, sectionChildren);\n    }\n\n    if (child.type === TableRow) {\n      return React.cloneElement(child as React.ReactElement<TableRowProps>, { variant });\n    }\n\n    return child;\n  });\n}\n\n// ─── Components ───────────────────────────────────────────────────────────────\n\n/**\n * Semantic wrapper for table header rows.\n *\n * @example\n * ```tsx\n * <TableHeader>\n *   <TableRow header>\n *     <TableCell>Name</TableCell>\n *     <TableCell>Price</TableCell>\n *   </TableRow>\n * </TableHeader>\n * ```\n */\nexport function TableHeader({ children, style }: TableSectionProps) {\n  return <View style={style}>{children}</View>;\n}\n\n/**\n * Semantic wrapper for table body rows.\n *\n * @example\n * ```tsx\n * <TableBody>\n *   <TableRow><TableCell>Item 1</TableCell></TableRow>\n * </TableBody>\n * ```\n */\nexport function TableBody({ children, style }: TableSectionProps) {\n  return <View style={style}>{children}</View>;\n}\n\n/**\n * Semantic wrapper for table footer rows.\n *\n * @example\n * ```tsx\n * <TableFooter>\n *   <TableRow footer><TableCell>Total</TableCell></TableRow>\n * </TableFooter>\n * ```\n */\nexport function TableFooter({ children, style }: TableSectionProps) {\n  return <View style={style}>{children}</View>;\n}\n\n/**\n * PDF table container component.\n * Supports four visual variants: line, grid, minimal, and striped.\n * All styling is theme-driven.\n *\n * @example\n * ```tsx\n * <Table variant=\"striped\">\n *   <TableHeader>\n *     <TableRow header>\n *       <TableCell width=\"50%\">Description</TableCell>\n *       <TableCell width=\"25%\" align=\"right\">Amount</TableCell>\n *     </TableRow>\n *   </TableHeader>\n *   <TableBody>\n *     <TableRow><TableCell width=\"50%\">Design</TableCell><TableCell width=\"25%\" align=\"right\">$2,000</TableCell></TableRow>\n *   </TableBody>\n * </Table>\n * ```\n */\nexport function Table({ children, style, variant = 'line', zebraStripe = false }: TableProps) {\n  const styles = getStyles(defaultTheme);\n  const tableStyles: Style[] = [styles.table];\n  const effectiveZebra = variant === 'striped' ? true : zebraStripe;\n\n  if (variant === 'grid') {\n    tableStyles.push(styles.tableGrid);\n  } else if (variant === 'line') {\n    tableStyles.push(styles.tableLine);\n  } else if (variant === 'minimal') {\n    tableStyles.push(styles.tableMinimal);\n  } else if (variant === 'striped') {\n    tableStyles.push(styles.tableStriped);\n  }\n\n  const styleArray = style ? [...tableStyles, style] : tableStyles;\n  const processedChildren = processTableChildren(children, variant, effectiveZebra);\n\n  return <View style={styleArray}>{processedChildren}</View>;\n}\n\n/**\n * PDF table row component.\n *\n * @example\n * ```tsx\n * <TableRow header>\n *   <TableCell>Column 1</TableCell>\n *   <TableCell>Column 2</TableCell>\n * </TableRow>\n * ```\n */\nexport function TableRow({\n  header,\n  footer,\n  stripe,\n  children,\n  style,\n  variant = 'line',\n}: TableRowProps) {\n  const styles = getStyles(defaultTheme);\n  const rowStyles: Style[] = [styles.row];\n\n  if (variant === 'grid') {\n    rowStyles.push(styles.rowGrid);\n  } else if (variant === 'line') {\n    rowStyles.push(styles.rowLine);\n  } else if (variant === 'minimal') {\n    rowStyles.push(styles.rowMinimal);\n  } else if (variant === 'striped') {\n    rowStyles.push(styles.rowStriped);\n  }\n\n  if (header) {\n    if (variant === 'line') rowStyles.push(styles.rowHeaderLine);\n    else if (variant === 'minimal') rowStyles.push(styles.rowHeaderMinimal);\n    else if (variant === 'striped') rowStyles.push(styles.rowHeaderStriped);\n    else rowStyles.push(styles.rowHeaderGrid);\n  }\n\n  if (footer) {\n    if (variant === 'striped') rowStyles.push(styles.rowFooterStriped);\n    else rowStyles.push(styles.rowFooter);\n  }\n\n  if (stripe && !header && !footer) {\n    rowStyles.push(styles.rowStripe);\n  }\n\n  const styleArray = style ? [...rowStyles, style] : rowStyles;\n  const childArray = React.Children.toArray(children);\n  const processedChildren = childArray.map((child, i) => {\n    if (React.isValidElement(child) && child.type === TableCell) {\n      return React.cloneElement(child as React.ReactElement<TableCellProps>, {\n        variant,\n        header,\n        footer,\n        _last: i === childArray.length - 1,\n      });\n    }\n    return child;\n  });\n\n  return <View style={styleArray}>{processedChildren}</View>;\n}\n\n/**\n * PDF table cell component.\n *\n * @example\n * ```tsx\n * <TableCell width=\"50%\" align=\"left\">Description</TableCell>\n * <TableCell width=\"25%\" align=\"right\">$1,000</TableCell>\n * ```\n */\nexport function TableCell({\n  header,\n  footer,\n  align,\n  width,\n  children,\n  style,\n  variant = 'line',\n  _last,\n}: TableCellProps) {\n  const styles = getStyles(defaultTheme);\n  const cellStyles: Style[] = [styles.cell];\n\n  if (width !== undefined) {\n    cellStyles.push(styles.cellFixed);\n    cellStyles.push({ width } as Style);\n  }\n\n  if (variant === 'minimal') {\n    cellStyles.push(styles.cellMinimal);\n  } else if (variant === 'striped') {\n    cellStyles.push(styles.cellStriped);\n  }\n\n  if (variant === 'grid' && !_last) {\n    cellStyles.push(styles.cellGridBorder);\n  }\n\n  if (align) {\n    cellStyles.push({ textAlign: align } as Style);\n  }\n\n  const styleArray = style ? [...cellStyles, style] : cellStyles;\n\n  let textStyle: Style = styles.cellText;\n  if (header) {\n    if (variant === 'line') textStyle = styles.cellTextHeaderLine;\n    else if (variant === 'minimal') textStyle = styles.cellTextHeaderMinimal;\n    else if (variant === 'striped') textStyle = styles.cellTextHeaderStriped;\n    else textStyle = styles.cellTextHeaderGrid;\n  } else if (footer) {\n    textStyle = styles.cellTextFooter;\n  }\n\n  const content =\n    typeof children === 'string' ? (\n      <PDFText style={[textStyle, align ? { textAlign: align } : {}]}>{children}</PDFText>\n    ) : (\n      children\n    );\n\n  return <View style={styleArray}>{content}</View>;\n}\n",
      "type": "registry:component"
    }
  ],
  "dependencies": [
    "@react-pdf/renderer"
  ],
  "registryDependencies": [
    "theme"
  ]
}