{
  "$schema": "https://pdfx.akashpise.dev/schema/registry-item.json",
  "name": "table",
  "type": "registry:ui",
  "title": "Table",
  "description": "Composable table with Table, TableRow, TableCell",
  "files": [
    {
      "path": "components/pdfx/pdfx-table.tsx",
      "content": "import { Text as PDFText, StyleSheet, View } from '@react-pdf/renderer';\nimport type { Style } from '@react-pdf/types';\nimport React from 'react';\nimport { usePdfxTheme, useSafeMemo } from '../../lib/pdfx-theme-context';\ntype PdfxTheme = ReturnType<typeof usePdfxTheme>;\n\nexport type TableVariant =\n  | 'line'\n  | 'grid'\n  | 'minimal'\n  | 'striped'\n  | 'compact'\n  | 'bordered'\n  | 'primary-header';\n\nexport interface TableProps {\n  /** Custom styles to merge with component defaults */\n  style?: Style;\n  /** Content to render */\n  children: React.ReactNode;\n  variant?: TableVariant;\n  zebraStripe?: boolean;\n  noWrap?: boolean;\n}\n\nexport interface TableSectionProps {\n  /** Custom styles to merge with component defaults */\n  style?: Style;\n  /** Content to render */\n  children: React.ReactNode;\n}\n\nexport interface TableRowProps {\n  /** Custom styles to merge with component defaults */\n  style?: Style;\n  /** Content to render */\n  children: React.ReactNode;\n  header?: boolean;\n  footer?: boolean;\n  stripe?: boolean;\n  variant?: TableVariant;\n}\n\nexport interface TableCellProps {\n  /** Custom styles to merge with component defaults */\n  style?: Style;\n  /** Content to render */\n  children: React.ReactNode;\n  header?: boolean;\n  footer?: boolean;\n  align?: 'left' | 'center' | 'right';\n  width?: string | number;\n  variant?: TableVariant;\n  _last?: boolean;\n}\n\n/** Derives all styles from theme tokens. Zero hardcoded values. */\nfunction createTableStyles(t: PdfxTheme) {\n  const { spacing, borderRadius, fontWeights, typography } = t.primitives;\n  const borderWidth = spacing[0.5];\n  const borderColor = t.colors.border;\n\n  return StyleSheet.create({\n    table: {\n      display: 'flex',\n      flexDirection: 'column',\n      width: '100%',\n      marginBottom: t.spacing.componentGap,\n    },\n    tableGrid: {\n      borderWidth: borderWidth,\n      borderColor: borderColor,\n      borderStyle: 'solid',\n      borderTopLeftRadius: borderRadius.md,\n      borderTopRightRadius: borderRadius.md,\n      borderBottomLeftRadius: borderRadius.md,\n      borderBottomRightRadius: borderRadius.md,\n      overflow: 'hidden' as const,\n    },\n    tableLine: {\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    tableMinimal: {\n      paddingVertical: spacing[2],\n    },\n    tableStriped: {\n      borderTopWidth: borderWidth,\n      borderTopColor: borderColor,\n      borderTopStyle: 'solid',\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    tableCompact: {\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    tableBordered: {\n      borderWidth: borderWidth * 2,\n      borderColor: borderColor,\n      borderStyle: 'solid',\n      overflow: 'hidden' as const,\n    },\n    tablePrimaryHeader: {\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    row: {\n      flexDirection: 'row',\n      display: 'flex',\n    },\n    rowGrid: {\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowLine: {\n      borderBottomWidth: 0,\n    },\n    rowMinimal: {\n      paddingVertical: spacing[1],\n    },\n    rowStriped: {},\n    rowCompact: {\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowBordered: {\n      borderBottomWidth: borderWidth * 2,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowPrimaryHeader: {\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderCompact: {\n      backgroundColor: t.colors.muted,\n      borderBottomWidth: borderWidth * 2,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderBordered: {\n      backgroundColor: t.colors.muted,\n      borderBottomWidth: borderWidth * 2,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderPrimaryHeader: {\n      backgroundColor: t.colors.primary,\n      borderBottomWidth: borderWidth * 2,\n      borderBottomColor: t.colors.primary,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderGrid: {\n      backgroundColor: t.colors.muted,\n      borderBottomWidth: borderWidth * 2,\n      borderBottomColor: t.colors.foreground,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderLine: {\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderMinimal: {\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderStriped: {\n      backgroundColor: t.colors.muted,\n      borderBottomWidth: borderWidth,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowFooter: {\n      borderTopWidth: borderWidth,\n      borderTopColor: borderColor,\n      borderTopStyle: 'solid',\n    },\n    rowFooterStriped: {\n      borderTopWidth: borderWidth,\n      borderTopColor: borderColor,\n      borderTopStyle: 'solid',\n      backgroundColor: t.colors.muted,\n    },\n    rowStripe: {\n      backgroundColor: t.colors.muted,\n    },\n    cell: {\n      flex: 1,\n      paddingVertical: spacing[3],\n      paddingHorizontal: spacing[4],\n    },\n    cellFixed: {\n      flex: 0,\n    },\n    cellGridBorder: {\n      borderRightWidth: borderWidth,\n      borderRightColor: borderColor,\n      borderRightStyle: 'solid',\n    },\n    cellMinimal: {\n      paddingVertical: spacing[2],\n      paddingHorizontal: spacing[3],\n    },\n    cellStriped: {\n      paddingVertical: spacing[2],\n      paddingHorizontal: spacing[4],\n    },\n    cellCompact: {\n      paddingVertical: spacing[0.5],\n      paddingHorizontal: spacing[3],\n    },\n    cellBordered: {\n      paddingVertical: spacing[3],\n      paddingHorizontal: spacing[4],\n    },\n    cellBorderedBorder: {\n      borderRightWidth: borderWidth * 2,\n      borderRightColor: borderColor,\n      borderRightStyle: 'solid',\n    },\n    cellPrimaryHeader: {\n      paddingVertical: spacing[3],\n      paddingHorizontal: spacing[4],\n    },\n    cellText: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n    },\n    cellTextHeaderGrid: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.semibold,\n    },\n    cellTextHeaderLine: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.semibold,\n    },\n    cellTextHeaderMinimal: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: typography.sm,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.medium,\n    },\n    cellTextHeaderStriped: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: typography.sm,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.semibold,\n    },\n    cellTextHeaderCompact: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: typography.xs,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.semibold,\n      textTransform: 'uppercase',\n      letterSpacing: 2,\n    },\n    cellTextHeaderBordered: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.bold,\n    },\n    cellTextHeaderPrimaryHeader: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: typography.xs,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.primaryForeground,\n      fontWeight: fontWeights.semibold,\n      textTransform: 'uppercase',\n      letterSpacing: 2,\n    },\n    cellTextCompact: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: typography.xs,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n    },\n    cellTextFooter: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.semibold,\n    },\n  });\n}\n\nfunction processTableChildren(\n  children: React.ReactNode,\n  variant: TableVariant,\n  zebraStripe: boolean\n): React.ReactNode {\n  let bodyRowIndex = 0;\n\n  return React.Children.map(children, (child) => {\n    if (!React.isValidElement(child)) return child;\n\n    if (child.type === TableHeader || child.type === TableBody || child.type === TableFooter) {\n      const isBody = child.type === TableBody;\n      const sectionChild = child as React.ReactElement<TableSectionProps>;\n      const sectionChildren = React.Children.map(sectionChild.props.children, (rowChild) => {\n        if (React.isValidElement(rowChild) && rowChild.type === TableRow) {\n          const rowProps: Partial<TableRowProps> = { variant };\n\n          if (isBody && zebraStripe) {\n            const isStripe = bodyRowIndex % 2 === 1;\n            bodyRowIndex++;\n            if (isStripe) {\n              rowProps.stripe = true;\n            }\n          }\n\n          return React.cloneElement(rowChild as React.ReactElement<TableRowProps>, rowProps);\n        }\n        return rowChild;\n      });\n\n      return React.cloneElement(child, {}, sectionChildren);\n    }\n\n    if (child.type === TableRow) {\n      return React.cloneElement(child as React.ReactElement<TableRowProps>, { variant });\n    }\n\n    return child;\n  });\n}\n\nexport function TableHeader({ children, style }: TableSectionProps) {\n  // minPresenceAhead: if < 60pt remain on the page, move the header to the next page\n  // so the header is never stranded alone at the bottom without any body rows.\n  return (\n    <View minPresenceAhead={60} style={style}>\n      {children}\n    </View>\n  );\n}\n\nexport function TableBody({ children, style }: TableSectionProps) {\n  return <View style={style}>{children}</View>;\n}\n\nexport function TableFooter({ children, style }: TableSectionProps) {\n  return <View style={style}>{children}</View>;\n}\n\nexport function Table({\n  children,\n  style,\n  variant = 'line',\n  zebraStripe = false,\n  noWrap = false,\n}: TableProps) {\n  const theme = usePdfxTheme();\n  const styles = useSafeMemo(() => createTableStyles(theme), [theme]);\n  const tableStyles: Style[] = [styles.table];\n  const effectiveZebra = variant === 'striped' ? true : zebraStripe;\n\n  if (variant === 'grid') {\n    tableStyles.push(styles.tableGrid);\n  } else if (variant === 'line') {\n    tableStyles.push(styles.tableLine);\n  } else if (variant === 'minimal') {\n    tableStyles.push(styles.tableMinimal);\n  } else if (variant === 'striped') {\n    tableStyles.push(styles.tableStriped);\n  } else if (variant === 'compact') {\n    tableStyles.push(styles.tableCompact);\n  } else if (variant === 'bordered') {\n    tableStyles.push(styles.tableBordered);\n  } else if (variant === 'primary-header') {\n    tableStyles.push(styles.tablePrimaryHeader);\n  }\n\n  const styleArray = style ? [...tableStyles, style] : tableStyles;\n  const processedChildren = processTableChildren(children, variant, effectiveZebra);\n\n  const inner = <View style={styleArray}>{processedChildren}</View>;\n  return noWrap ? <View wrap={false}>{inner}</View> : inner;\n}\n\nexport function TableRow({\n  header,\n  footer,\n  stripe,\n  children,\n  style,\n  variant = 'line',\n}: TableRowProps) {\n  const theme = usePdfxTheme();\n  const styles = useSafeMemo(() => createTableStyles(theme), [theme]);\n  const rowStyles: Style[] = [styles.row];\n\n  if (variant === 'grid') {\n    rowStyles.push(styles.rowGrid);\n  } else if (variant === 'line') {\n    rowStyles.push(styles.rowLine);\n  } else if (variant === 'minimal') {\n    rowStyles.push(styles.rowMinimal);\n  } else if (variant === 'striped') {\n    rowStyles.push(styles.rowStriped);\n  } else if (variant === 'compact') {\n    rowStyles.push(styles.rowCompact);\n  } else if (variant === 'bordered') {\n    rowStyles.push(styles.rowBordered);\n  } else if (variant === 'primary-header') {\n    rowStyles.push(styles.rowPrimaryHeader);\n  }\n\n  if (header) {\n    if (variant === 'line') rowStyles.push(styles.rowHeaderLine);\n    else if (variant === 'minimal') rowStyles.push(styles.rowHeaderMinimal);\n    else if (variant === 'striped') rowStyles.push(styles.rowHeaderStriped);\n    else if (variant === 'compact') rowStyles.push(styles.rowHeaderCompact);\n    else if (variant === 'bordered') rowStyles.push(styles.rowHeaderBordered);\n    else if (variant === 'primary-header') rowStyles.push(styles.rowHeaderPrimaryHeader);\n    else rowStyles.push(styles.rowHeaderGrid);\n  }\n\n  if (footer) {\n    if (variant === 'striped') rowStyles.push(styles.rowFooterStriped);\n    else rowStyles.push(styles.rowFooter);\n  }\n\n  if (stripe && !header && !footer) {\n    rowStyles.push(styles.rowStripe);\n  }\n\n  const styleArray = style ? [...rowStyles, style] : rowStyles;\n  const childArray = React.Children.toArray(children);\n  const processedChildren = childArray.map((child, i) => {\n    if (React.isValidElement(child) && child.type === TableCell) {\n      return React.cloneElement(child as React.ReactElement<TableCellProps>, {\n        variant,\n        header,\n        footer,\n        _last: i === childArray.length - 1,\n      });\n    }\n    return child;\n  });\n\n  // wrap={false}: each row is atomic â€” never split mid-row across pages.\n  return (\n    <View wrap={false} style={styleArray}>\n      {processedChildren}\n    </View>\n  );\n}\n\nexport function TableCell({\n  header,\n  footer,\n  align,\n  width,\n  children,\n  style,\n  variant = 'line',\n  _last,\n}: TableCellProps) {\n  const theme = usePdfxTheme();\n  const styles = useSafeMemo(() => createTableStyles(theme), [theme]);\n  const cellStyles: Style[] = [styles.cell];\n\n  if (width !== undefined) {\n    cellStyles.push(styles.cellFixed);\n    cellStyles.push({ width } as Style);\n  }\n\n  if (variant === 'minimal') {\n    cellStyles.push(styles.cellMinimal);\n  } else if (variant === 'striped') {\n    cellStyles.push(styles.cellStriped);\n  } else if (variant === 'compact') {\n    cellStyles.push(styles.cellCompact);\n  } else if (variant === 'bordered') {\n    cellStyles.push(styles.cellBordered);\n  } else if (variant === 'primary-header') {\n    cellStyles.push(styles.cellPrimaryHeader);\n  }\n\n  if (variant === 'grid' && !_last) {\n    cellStyles.push(styles.cellGridBorder);\n  } else if (variant === 'bordered' && !_last) {\n    cellStyles.push(styles.cellBorderedBorder);\n  }\n\n  if (align) {\n    cellStyles.push({ textAlign: align } as Style);\n  }\n\n  const styleArray = style ? [...cellStyles, style] : cellStyles;\n\n  let textStyle: Style = styles.cellText;\n  if (header) {\n    if (variant === 'line') textStyle = styles.cellTextHeaderLine;\n    else if (variant === 'minimal') textStyle = styles.cellTextHeaderMinimal;\n    else if (variant === 'striped') textStyle = styles.cellTextHeaderStriped;\n    else if (variant === 'compact') textStyle = styles.cellTextHeaderCompact;\n    else if (variant === 'bordered') textStyle = styles.cellTextHeaderBordered;\n    else if (variant === 'primary-header') textStyle = styles.cellTextHeaderPrimaryHeader;\n    else textStyle = styles.cellTextHeaderGrid;\n  } else if (footer) {\n    textStyle = styles.cellTextFooter;\n  } else if (variant === 'compact') {\n    textStyle = styles.cellTextCompact;\n  }\n\n  const content =\n    typeof children === 'string' ? (\n      <PDFText style={[textStyle, align ? { textAlign: align } : {}]}>{children}</PDFText>\n    ) : (\n      children\n    );\n\n  return <View style={styleArray}>{content}</View>;\n}\n",
      "type": "registry:component"
    }
  ],
  "dependencies": [
    "@react-pdf/renderer"
  ],
  "registryDependencies": [
    "theme"
  ]
}