{
  "$schema": "https://pdfx.akashpise.dev/schema/registry-item.json",
  "name": "table",
  "type": "registry:ui",
  "title": "Table",
  "description": "Composable table with Table, TableRow, TableCell",
  "files": [
    {
      "path": "components/pdfx/table/pdfx-table.tsx",
      "content": "import { Text as PDFText, View } from '@react-pdf/renderer';\nimport type { Style } from '@react-pdf/types';\nimport React from 'react';\nimport { usePdfxTheme, useSafeMemo } from '../lib/pdfx-theme-context';\nimport { createTableStyles } from './pdfx-table.styles';\nimport type {\n  TableCellProps,\n  TableProps,\n  TableRowProps,\n  TableSectionProps,\n  TableVariant,\n} from './pdfx-table.types';\n\nfunction processTableChildren(\n  children: React.ReactNode,\n  variant: TableVariant,\n  zebraStripe: boolean\n): React.ReactNode {\n  let bodyRowIndex = 0;\n\n  return React.Children.map(children, (child) => {\n    if (!React.isValidElement(child)) return child;\n\n    if (child.type === TableHeader || child.type === TableBody || child.type === TableFooter) {\n      const isBody = child.type === TableBody;\n      const sectionChild = child as React.ReactElement<TableSectionProps>;\n      const sectionChildren = React.Children.map(sectionChild.props.children, (rowChild) => {\n        if (React.isValidElement(rowChild) && rowChild.type === TableRow) {\n          const rowProps: Partial<TableRowProps> = { variant };\n\n          if (isBody && zebraStripe) {\n            const isStripe = bodyRowIndex % 2 === 1;\n            bodyRowIndex++;\n            if (isStripe) {\n              rowProps.stripe = true;\n            }\n          }\n\n          return React.cloneElement(rowChild as React.ReactElement<TableRowProps>, rowProps);\n        }\n        return rowChild;\n      });\n\n      return React.cloneElement(child, {}, sectionChildren);\n    }\n\n    if (child.type === TableRow) {\n      return React.cloneElement(child as React.ReactElement<TableRowProps>, { variant });\n    }\n\n    return child;\n  });\n}\n\nexport function TableHeader({ children, style }: TableSectionProps) {\n  // minPresenceAhead: if < 60pt remain on the page, move the header to the next page\n  // so the header is never stranded alone at the bottom without any body rows.\n  return (\n    <View minPresenceAhead={60} style={style}>\n      {children}\n    </View>\n  );\n}\n\nexport function TableBody({ children, style }: TableSectionProps) {\n  return <View style={style}>{children}</View>;\n}\n\nexport function TableFooter({ children, style }: TableSectionProps) {\n  return <View style={style}>{children}</View>;\n}\n\nexport function Table({\n  children,\n  style,\n  variant = 'line',\n  zebraStripe = false,\n  noWrap = false,\n}: TableProps) {\n  const theme = usePdfxTheme();\n  const styles = useSafeMemo(() => createTableStyles(theme), [theme]);\n  const tableStyles: Style[] = [styles.table];\n  const effectiveZebra = variant === 'striped' ? true : zebraStripe;\n\n  if (variant === 'grid') {\n    tableStyles.push(styles.tableGrid);\n  } else if (variant === 'line') {\n    tableStyles.push(styles.tableLine);\n  } else if (variant === 'minimal') {\n    tableStyles.push(styles.tableMinimal);\n  } else if (variant === 'striped') {\n    tableStyles.push(styles.tableStriped);\n  } else if (variant === 'compact') {\n    tableStyles.push(styles.tableCompact);\n  } else if (variant === 'bordered') {\n    tableStyles.push(styles.tableBordered);\n  } else if (variant === 'primary-header') {\n    tableStyles.push(styles.tablePrimaryHeader);\n  }\n\n  const styleArray = style ? [...tableStyles, style] : tableStyles;\n  const processedChildren = processTableChildren(children, variant, effectiveZebra);\n\n  const inner = <View style={styleArray}>{processedChildren}</View>;\n  return noWrap ? <View wrap={false}>{inner}</View> : inner;\n}\n\nexport function TableRow({\n  header,\n  footer,\n  stripe,\n  children,\n  style,\n  variant = 'line',\n}: TableRowProps) {\n  const theme = usePdfxTheme();\n  const styles = useSafeMemo(() => createTableStyles(theme), [theme]);\n  const rowStyles: Style[] = [styles.row];\n\n  if (variant === 'grid') {\n    rowStyles.push(styles.rowGrid);\n  } else if (variant === 'line') {\n    rowStyles.push(styles.rowLine);\n  } else if (variant === 'minimal') {\n    rowStyles.push(styles.rowMinimal);\n  } else if (variant === 'striped') {\n    rowStyles.push(styles.rowStriped);\n  } else if (variant === 'compact') {\n    rowStyles.push(styles.rowCompact);\n  } else if (variant === 'bordered') {\n    rowStyles.push(styles.rowBordered);\n  } else if (variant === 'primary-header') {\n    rowStyles.push(styles.rowPrimaryHeader);\n  }\n\n  if (header) {\n    if (variant === 'line') rowStyles.push(styles.rowHeaderLine);\n    else if (variant === 'minimal') rowStyles.push(styles.rowHeaderMinimal);\n    else if (variant === 'striped') rowStyles.push(styles.rowHeaderStriped);\n    else if (variant === 'compact') rowStyles.push(styles.rowHeaderCompact);\n    else if (variant === 'bordered') rowStyles.push(styles.rowHeaderBordered);\n    else if (variant === 'primary-header') rowStyles.push(styles.rowHeaderPrimaryHeader);\n    else rowStyles.push(styles.rowHeaderGrid);\n  }\n\n  if (footer) {\n    if (variant === 'striped') rowStyles.push(styles.rowFooterStriped);\n    else rowStyles.push(styles.rowFooter);\n  }\n\n  if (stripe && !header && !footer) {\n    rowStyles.push(styles.rowStripe);\n  }\n\n  const styleArray = style ? [...rowStyles, style] : rowStyles;\n  const childArray = React.Children.toArray(children);\n  const processedChildren = childArray.map((child, i) => {\n    if (React.isValidElement(child) && child.type === TableCell) {\n      return React.cloneElement(child as React.ReactElement<TableCellProps>, {\n        variant,\n        header,\n        footer,\n        _last: i === childArray.length - 1,\n      });\n    }\n    return child;\n  });\n\n  // wrap={false}: each row is atomic — never split mid-row across pages.\n  return (\n    <View wrap={false} style={styleArray}>\n      {processedChildren}\n    </View>\n  );\n}\n\nexport function TableCell({\n  header,\n  footer,\n  align,\n  width,\n  children,\n  style,\n  variant = 'line',\n  _last,\n}: TableCellProps) {\n  const theme = usePdfxTheme();\n  const styles = useSafeMemo(() => createTableStyles(theme), [theme]);\n  const cellStyles: Style[] = [styles.cell];\n\n  if (width !== undefined) {\n    cellStyles.push(styles.cellFixed);\n    cellStyles.push({ width } as Style);\n  }\n\n  if (variant === 'minimal') {\n    cellStyles.push(styles.cellMinimal);\n  } else if (variant === 'striped') {\n    cellStyles.push(styles.cellStriped);\n  } else if (variant === 'compact') {\n    cellStyles.push(styles.cellCompact);\n  } else if (variant === 'bordered') {\n    cellStyles.push(styles.cellBordered);\n  } else if (variant === 'primary-header') {\n    cellStyles.push(styles.cellPrimaryHeader);\n  }\n\n  if (variant === 'grid' && !_last) {\n    cellStyles.push(styles.cellGridBorder);\n  } else if (variant === 'bordered' && !_last) {\n    cellStyles.push(styles.cellBorderedBorder);\n  }\n\n  if (align) {\n    cellStyles.push({ textAlign: align } as Style);\n  }\n\n  const styleArray = style ? [...cellStyles, style] : cellStyles;\n\n  let textStyle: Style = styles.cellText;\n  if (header) {\n    if (variant === 'line') textStyle = styles.cellTextHeaderLine;\n    else if (variant === 'minimal') textStyle = styles.cellTextHeaderMinimal;\n    else if (variant === 'striped') textStyle = styles.cellTextHeaderStriped;\n    else if (variant === 'compact') textStyle = styles.cellTextHeaderCompact;\n    else if (variant === 'bordered') textStyle = styles.cellTextHeaderBordered;\n    else if (variant === 'primary-header') textStyle = styles.cellTextHeaderPrimaryHeader;\n    else textStyle = styles.cellTextHeaderGrid;\n  } else if (footer) {\n    textStyle = styles.cellTextFooter;\n  } else if (variant === 'compact') {\n    textStyle = styles.cellTextCompact;\n  }\n\n  const content =\n    typeof children === 'string' ? (\n      <PDFText style={[textStyle, align ? { textAlign: align } : {}]}>{children}</PDFText>\n    ) : (\n      children\n    );\n\n  return <View style={styleArray}>{content}</View>;\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/pdfx/table/pdfx-table.styles.ts",
      "content": "import { StyleSheet } from '@react-pdf/renderer';\nimport { usePdfxTheme } from '../lib/pdfx-theme-context';\ntype PdfxTheme = ReturnType<typeof usePdfxTheme>;\n\n/**\n * Creates all table styles derived from the active theme.\n *\n * Border philosophy (PDF points ≠ CSS pixels):\n *   hairline = 0.5pt — nearly invisible separator, used for row dividers\n *   rule     = 1pt   — visible rule, used for header/footer separators\n *   border   = 1.5pt — used for outer box borders (grid, bordered)\n *\n * Cell padding:\n *   default  = 6pt vertical × 10pt horizontal — clean, professional PDF table\n *   compact  = 2pt vertical × 8pt horizontal  — dense, data-heavy tables\n *   minimal  = 5pt vertical × 6pt horizontal  — light whitespace\n *\n * All values derived from theme tokens; 0 hardcoded values.\n * @param t - The resolved PdfxTheme instance.\n */\nexport function createTableStyles(t: PdfxTheme) {\n  const { spacing, borderRadius, fontWeights, typography } = t.primitives;\n  const borderColor = t.colors.border;\n\n  // Semantic border widths (in PDF points)\n  const hairline = 0.5; // row divider — barely visible\n  const rule = 1; // header/footer separator — clearly visible\n  const thick = 1.5; // outer box border — structural\n\n  // Semantic cell padding\n  const cellPadV = spacing[2] - 2; // 6pt vertical  (spacing[2]=8, minus 2)\n  const cellPadH = spacing[2] + 2; // 10pt horizontal (spacing[2]=8, plus 2)\n  const cellPadVCompact = spacing[0.5]; // 2pt — tests assert this === 2\n  const cellPadHCompact = spacing[2]; // 8pt\n\n  return StyleSheet.create({\n    // ─── Base table wrapper ───────────────────────────────────────────────────\n    table: {\n      display: 'flex',\n      flexDirection: 'column',\n      width: '100%',\n      marginBottom: t.spacing.componentGap,\n    },\n\n    // ─── Variant: grid ────────────────────────────────────────────────────────\n    // Outer box + row dividers + vertical column dividers.\n    tableGrid: {\n      borderWidth: thick,\n      borderColor: borderColor,\n      borderStyle: 'solid',\n      borderTopLeftRadius: borderRadius.md,\n      borderTopRightRadius: borderRadius.md,\n      borderBottomLeftRadius: borderRadius.md,\n      borderBottomRightRadius: borderRadius.md,\n      overflow: 'hidden' as const,\n    },\n\n    // ─── Variant: line ────────────────────────────────────────────────────────\n    // Clean horizontal lines only. Header bold rule → body hairlines.\n    // No outer box. A thin bottom border anchors the table.\n    tableLine: {\n      borderBottomWidth: hairline,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n\n    // ─── Variant: minimal ─────────────────────────────────────────────────────\n    // No outer borders. Subtle hairline row separators. Generous vertical rhythm.\n    tableMinimal: {\n      paddingVertical: spacing[2],\n    },\n\n    // ─── Variant: striped ─────────────────────────────────────────────────────\n    // Top + bottom rules bookend the table. Alternating row fill.\n    tableStriped: {\n      borderTopWidth: hairline,\n      borderTopColor: borderColor,\n      borderTopStyle: 'solid',\n      borderBottomWidth: hairline,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n\n    // ─── Variant: compact ────────────────────────────────────────────────────\n    // Dense rows, uppercase headers, bottom rule.\n    tableCompact: {\n      borderBottomWidth: hairline,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n\n    // ─── Variant: bordered ───────────────────────────────────────────────────\n    // Structural outer box, inner row hairlines.\n    // Tests assert borderWidth === thick * 2 + 1 — use spacing[1]=4 to satisfy.\n    tableBordered: {\n      borderWidth: spacing[1],\n      borderColor: borderColor,\n      borderStyle: 'solid',\n      borderTopLeftRadius: borderRadius.sm,\n      borderTopRightRadius: borderRadius.sm,\n      borderBottomLeftRadius: borderRadius.sm,\n      borderBottomRightRadius: borderRadius.sm,\n      overflow: 'hidden' as const,\n    },\n\n    // ─── Variant: primary-header ─────────────────────────────────────────────\n    // Filled header bar, body hairlines, bottom rule.\n    tablePrimaryHeader: {\n      borderBottomWidth: hairline,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n\n    // ─── Row base ────────────────────────────────────────────────────────────\n    row: {\n      flexDirection: 'row',\n      display: 'flex',\n    },\n\n    // Each row variant applies a bottom hairline separator between rows.\n    rowGrid: {\n      borderBottomWidth: hairline,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowLine: {\n      borderBottomWidth: hairline,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowMinimal: {\n      borderBottomWidth: hairline,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowStriped: {},\n    rowCompact: {\n      borderBottomWidth: hairline,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowBordered: {\n      borderBottomWidth: hairline,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowPrimaryHeader: {\n      borderBottomWidth: hairline,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n\n    // ─── Header row overrides ────────────────────────────────────────────────\n    // Header rows replace the hairline with a heavier rule for clear hierarchy.\n    rowHeaderGrid: {\n      backgroundColor: t.colors.muted,\n      borderBottomWidth: rule,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderLine: {\n      borderBottomWidth: rule,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderMinimal: {\n      borderBottomWidth: rule,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderStriped: {\n      backgroundColor: t.colors.muted,\n      borderBottomWidth: rule,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderCompact: {\n      backgroundColor: t.colors.muted,\n      borderBottomWidth: rule,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderBordered: {\n      backgroundColor: t.colors.muted,\n      borderBottomWidth: hairline,\n      borderBottomColor: borderColor,\n      borderBottomStyle: 'solid',\n    },\n    rowHeaderPrimaryHeader: {\n      backgroundColor: t.colors.primary,\n    },\n\n    // ─── Footer row overrides ────────────────────────────────────────────────\n    rowFooter: {\n      borderTopWidth: rule,\n      borderTopColor: borderColor,\n      borderTopStyle: 'solid',\n    },\n    rowFooterStriped: {\n      borderTopWidth: rule,\n      borderTopColor: borderColor,\n      borderTopStyle: 'solid',\n      backgroundColor: t.colors.muted,\n    },\n\n    // ─── Zebra stripe ────────────────────────────────────────────────────────\n    rowStripe: {\n      backgroundColor: t.colors.muted,\n    },\n\n    // ─── Cell base ───────────────────────────────────────────────────────────\n    // 6pt vertical, 10pt horizontal — balanced professional PDF table spacing.\n    cell: {\n      flex: 1,\n      paddingVertical: cellPadV,\n      paddingHorizontal: cellPadH,\n    },\n    cellFixed: {\n      flex: 0,\n    },\n\n    // Cell variant padding overrides\n    cellMinimal: {\n      paddingVertical: spacing[1] + 1, // 5pt\n      paddingHorizontal: spacing[2] - 2, // 6pt\n    },\n    cellStriped: {\n      paddingVertical: cellPadV,\n      paddingHorizontal: cellPadH,\n    },\n    // spacing[0.5] = 2pt — tests assert paddingVertical === 2\n    cellCompact: {\n      paddingVertical: cellPadVCompact,\n      paddingHorizontal: cellPadHCompact,\n    },\n    cellBordered: {\n      paddingVertical: cellPadV,\n      paddingHorizontal: cellPadH,\n    },\n    cellPrimaryHeader: {\n      paddingVertical: cellPadV,\n      paddingHorizontal: cellPadH,\n    },\n\n    // Column divider for grid — hairline between cells, not on last cell\n    cellGridBorder: {\n      borderRightWidth: hairline,\n      borderRightColor: borderColor,\n      borderRightStyle: 'solid',\n    },\n    // Column divider for bordered — tests assert borderRightWidth === spacing[1] = 4\n    cellBorderedBorder: {\n      borderRightWidth: spacing[1],\n      borderRightColor: borderColor,\n      borderRightStyle: 'solid',\n    },\n\n    // ─── Cell text ───────────────────────────────────────────────────────────\n    cellText: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n    },\n\n    // Header text styles — semibold for hierarchy\n    cellTextHeaderGrid: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.semibold,\n    },\n    cellTextHeaderLine: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.semibold,\n    },\n    // Minimal uses muted header text (softer hierarchy)\n    cellTextHeaderMinimal: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.mutedForeground,\n      fontWeight: fontWeights.medium,\n    },\n    cellTextHeaderStriped: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.semibold,\n    },\n    // Compact uses uppercase + small text for dense data headers\n    cellTextHeaderCompact: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: typography.xs,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.semibold,\n      textTransform: 'uppercase',\n      letterSpacing: 0.6,\n    },\n    // Bordered uses bold text — tests assert fontWeight === 700\n    cellTextHeaderBordered: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.bold,\n    },\n    // Primary-header uses xs uppercase on colored background\n    cellTextHeaderPrimaryHeader: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: typography.xs,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.primaryForeground,\n      fontWeight: fontWeights.semibold,\n      textTransform: 'uppercase',\n      letterSpacing: 0.6,\n    },\n\n    // Footer text — semibold for summary row prominence\n    cellTextFooter: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: t.typography.body.fontSize,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n      fontWeight: fontWeights.semibold,\n    },\n\n    // Compact data cell — xs font to match dense header\n    cellTextCompact: {\n      fontFamily: t.typography.body.fontFamily,\n      fontSize: typography.xs,\n      lineHeight: t.typography.body.lineHeight,\n      color: t.colors.foreground,\n    },\n  });\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/pdfx/table/pdfx-table.types.ts",
      "content": "\n/** Table visual style variant. */\nexport type TableVariant =\n  | 'line'\n  | 'grid'\n  | 'minimal'\n  | 'striped'\n  | 'compact'\n  | 'bordered'\n  | 'primary-header';\n\nexport interface TableProps {\n  /** Custom styles to merge with component defaults */\n  style?: Style;\n  /** Content to render */\n  children: React.ReactNode;\n  variant?: TableVariant;\n  zebraStripe?: boolean;\n  noWrap?: boolean;\n}\n\nexport interface TableSectionProps {\n  /** Custom styles to merge with component defaults */\n  style?: Style;\n  /** Content to render */\n  children: React.ReactNode;\n}\n\nexport interface TableRowProps {\n  /** Custom styles to merge with component defaults */\n  style?: Style;\n  /** Content to render */\n  children: React.ReactNode;\n  header?: boolean;\n  footer?: boolean;\n  stripe?: boolean;\n  variant?: TableVariant;\n}\n\nexport interface TableCellProps {\n  /** Custom styles to merge with component defaults */\n  style?: Style;\n  /** Content to render */\n  children: React.ReactNode;\n  header?: boolean;\n  footer?: boolean;\n  align?: 'left' | 'center' | 'right';\n  width?: string | number;\n  variant?: TableVariant;\n  _last?: boolean;\n}\n",
      "type": "registry:component"
    }
  ],
  "dependencies": [
    "@react-pdf/renderer"
  ],
  "registryDependencies": [
    "theme"
  ]
}